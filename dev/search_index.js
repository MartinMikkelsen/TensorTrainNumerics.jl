var documenterSearchIndex = {"docs":
[{"location":"resources/#Resources","page":"Resources","title":"Resources","text":"","category":"section"},{"location":"resources/#Notes-and-Lectures","page":"Resources","title":"Notes and Lectures","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"Tensor trains for high-dimensional problems by Mi-Song Dupuy","category":"page"},{"location":"resources/#Software-and-Libraries","page":"Resources","title":"Software and Libraries","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"Scikit-TT\nTT-Toolbox\nttpy\nKrylovKit.jl\nTT-Toolbox\nMPSTime.jl\nITensorNumericalAnalysis.jl\nTensor-Train-Julia\nITensorQTT.jl","category":"page"},{"location":"resources/#References","page":"Resources","title":"References","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"I. Oseledets. Tensor-Train Decomposition. SIAM Journal on Scientific Computing 33, 2295–2317 (2011).\n\n\n\nU. Schollwöck. The density-matrix renormalization group in the age of matrix product states. Annals of Physics 326, 96–192 (2011).\n\n\n\nL. Devos, M. Van Damme and J. Haegeman. TensorOperations.jl (2023).\n\n\n\nV. A. Kazeev and B. N. Khoromskij. Low-rank explicit QTT representation of the Laplace operator and its inverse. SIAM Journal on Matrix Analysis and Applications 33, 742–758 (2012).\n\n\n\nB. N. Khoromskij. Tensor Numerical Methods in Scientific Computing (De Gruyter, Berlin, Boston, 2018).\n\n\n\nB. Khoromskij. O(d log N)-Quantics Approximation of N - d Tensors in High-Dimensional Numerical Modeling. Constructive Approximation 34 (2009).\n\n\n\nS. R. White. Density matrix formulation for quantum renormalization groups. Physical Review Letters 69, 2863–2866 (1992).\n\n\n\nJ. Haegeman, C. Lubich, I. Oseledets, B. Vandereycken and F. Verstraete. Unifying time evolution and optimization with matrix product states. Physical Review B 94, 165116 (2016).\n\n\n\nL. Vanderstraeten, J. Haegeman and F. Verstraete. Tangent-space methods for uniform matrix product states. SciPost Physics Lecture Notes (2019).\n\n\n\nS. Holtz, T. Rohwedder and R. Schneider. The Alternating Linear Scheme for Tensor Optimization in the Tensor Train Format. SIAM Journal on Scientific Computing 34, A683–A713 (2012).\n\n\n\nM. Lindsey. Multiscale interpolative construction of quantized tensor trains, arXiv preprint arXiv:2311.12554 (2023).\n\n\n\nS. Dolgov, B. Khoromskij and D. Savostyanov. Superfast Fourier Transform Using QTT Approximation. Journal of Fourier Analysis and Applications 18, 915–953 (2012).\n\n\n\nJ. Chen and M. Lindsey. Direct interpolative construction of the discrete Fourier transform as a matrix product operator (2024), arXiv:2404.03182 [quant-ph].\n\n\n\nJ. Chen, E. M. Stoudenmire and S. R. White. Quantum Fourier transform has small entanglement. PRX Quantum 4, 040318 (2023).\n\n\n\nL. Arenstein, M. Mikkelsen and M. Kastoryano. Fast and Flexible Quantum-Inspired Differential Equation Solvers with Data Integration (2025), arXiv:2505.17046 [math.NA].\n\n\n\n","category":"page"},{"location":"theory/#Quantics-tensor-trains","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"","category":"section"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"Quantics tensor trains (QTT) are a powerful tool for representing and manipulating high-dimensional data in a compressed format. They are particularly useful for solving high-dimensional partial differential equations and large-scale linear algebra problems, where traditional methods may be computationally infeasible due to the curse of dimensionality.","category":"page"},{"location":"theory/#Defining-tensor-train-vectors","page":"Quantics tensor trains","title":"Defining tensor train vectors","text":"","category":"section"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"You can construct a quantics tensor train in several ways. The most straightforward way is to use the function function_to_qtt, which takes a function and a discretization level as input and returns a QTT representation of the function evaluated on a uniform grid.","category":"page"},{"location":"theory/#Mathematical-functions-in-QTT-format","page":"Quantics tensor trains","title":"Mathematical functions in QTT format","text":"","category":"section"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"You can also use the built-in functions for common mathematical functions, such as qtt_exp, qtt_sin, qtt_cos, qtt_polynom, and qtt_chebyshev. These functions provide efficient QTT representations of the corresponding mathematical functions [5]. These are illustrated in the following ","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"using TensorTrainNumerics\nusing CairoMakie\n\nd = 8\n\nA1 = qtt_exp(d)\nA2 = qtt_sin(d, λ = π)\nA3 = qtt_cos(d, λ = π)\nA4 = qtt_polynom([0.0, 2.0, 3.0, -8.0, -5.0], d; a = 0.0, b = 1.0)\n\n\nqtt_values_exponential = qtt_to_function(A1)\nqtt_values_sin = qtt_to_function(A2)\nqtt_values_cos = qtt_to_function(A3)\nqtt_values_polynom = qtt_to_function(A4)\n\n\nvalues_exp(x) = exp(x)\nvalues_sin(x) = sin(x * π^2)\nvalues_cos(x) = cos(x * π^2)\nvalues_polynom(x) = 2 * x + 3 * x^2 - 8 * x^3 - 5 * x^4\n\nx_points = LinRange(0, 1, 2^8)\noriginal_values_exponential = values_exp.(x_points)\noriginal_values_sin = values_sin.(x_points)\noriginal_values_cos = values_cos.(x_points)\noriginal_values_polynom = values_polynom.(x_points)\n\nlet\n    fig = Figure()\n    ax1 = Axis(fig[2, 2], title = \"Exp Approximation\", xlabel = \"x\", ylabel = \"f(x)\")\n    ax2 = Axis(fig[1, 1], title = \"Sin Approximation\", xlabel = \"x\", ylabel = \"f(x)\")\n    ax3 = Axis(fig[1, 2], title = \"Cos Approximation\", xlabel = \"x\", ylabel = \"f(x)\")\n    ax4 = Axis(fig[2, 1], title = \"Polynomial Approximation\", xlabel = \"x\", ylabel = \"f(x)\")\n\n\n    lines!(ax1, x_points, original_values_exponential, label = \"Exponential function\")\n    lines!(ax1, x_points, qtt_values_exponential, label = \"QTT exponential function\", linestyle = :dash, color = :green)\n\n    lines!(ax2, x_points, original_values_sin, label = \"Sine function\")\n    lines!(ax2, x_points, qtt_values_sin, label = \"QTT sine function\", linestyle = :dash, color = :red)\n\n    lines!(ax3, x_points, original_values_cos, label = \"Sine function\")\n    lines!(ax3, x_points, qtt_values_cos, label = \"QTT sine function\", linestyle = :dash, color = :red)\n\n    lines!(ax4, x_points, original_values_polynom, label = \"Sine function\")\n    lines!(ax4, x_points, qtt_values_polynom, label = \"QTT sine function\", linestyle = :dash, color = :red)\n\n    fig\nend","category":"page"},{"location":"theory/#Interpolation-based-QTT-construction","page":"Quantics tensor trains","title":"Interpolation-based QTT construction","text":"","category":"section"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"You can also build a QTT based on interpolation techniques based on [11]. The function interpolating_qtt constructs a QTT representation of a given function using polynomial interpolation at Chebyshev nodes. Another option is to use the function lagrange_rank_revealing, which constructs a QTT representation using a rank-revealing approach based on Lagrange interpolation as shown in this example","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"We can also do interpolation in the QTT framework:","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"using CairoMakie\nusing TensorTrainNumerics\n\nf = x -> cos(1 / (x^3 + 0.01)) + sin(π * x)\nnum_cores = 10  \nN = 150 \n\nqtt = interpolating_qtt(f, num_cores, N)\nqtt_rank_revealing = lagrange_rank_revealing(f, num_cores, N)\n\nqtt_values = matricize(qtt, num_cores)\nqtt_values_rank_revealing = matricize(qtt_rank_revealing, num_cores)\n\nx_points = LinRange(0, 1, 2^num_cores)\noriginal_values = f.(x_points)\n\nfig = Figure()\nax = Axis(fig[1, 1], title=\"Function Approximation\", xlabel=\"x\", ylabel=\"f(x)\")\n\nlines!(ax, x_points, original_values, label=\"Original Function\")\nlines!(ax, x_points, qtt_values_rank_revealing, label=\"QTT, rank rev.\", linestyle=:dash, color=:green)\nlines!(ax, x_points, qtt_values, label=\"QTT\", linestyle=:dash, color=:red)\n\naxislegend(ax)\nfig","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"We can visualize the interpolating QTT as ","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"visualize(qtt)","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"And similarly for the rank-revealing","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"visualize(qtt_rank_revealing)","category":"page"},{"location":"theory/#Defining-tensor-train-operators","page":"Quantics tensor trains","title":"Defining tensor train operators","text":"","category":"section"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"Suppose we want to construct the finite difference discretization of the second derivative operator with Dirichlet-Neumann boundary conditions on the interval ([0, 1]). We can use the function Δ_DN to create a QTT representation of the corresponding tridiagonal matrix. ","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"using TensorTrainNumerics\n\nd = 8\nA = Δ_DN(d)","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"And we can check the matrix representation by matricizing it","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"mat_A = qtto_to_matrix(A)","category":"page"},{"location":"theory/#Solving-equations-in-the-QTT-framework","page":"Quantics tensor trains","title":"Solving equations in the QTT framework","text":"","category":"section"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"To illustrate how to solve a differential equation consider the following 1D heat/diffusion equation in semi-discrete form with Dirichlet-Dirichlet boundary conditions","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"beginaligned\nu_t(xt) = u_xx(xt)qquad xin(01) tge 0\nu(x0) = sin(pi x)\nu(0t)=0quad u(1t)=0\nendaligned","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"We define the operator","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"using TensorTrainNumerics\nusing CairoMakie\nusing KrylovKit\n\nd = 8\nN = 2^d\nh = 1 / (N-1)\nxes = collect(range(0.0, 1.0, 2^d))\nA = h^2 * toeplitz_to_qtto(-2, 1.0, 1.0, d)","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"We then define some initial condition, random guess and some time steps","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"u₀ = qtt_sin(d, λ = π) # sin(π^2 x)\nsteps = collect(range(0.0, 10.0, 1000))\ninit = rand_tt(u₀.ttv_dims, u₀.ttv_rks)","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"Finally, we can solve the problem using the explicit Euler method, the implicit Euler method, the Crank-Nicolson scheme and a Krylov-based exponential integrator","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"\nsolution_implicit, rel_implicit = implicit_euler_method(A, u₀, init, steps; return_error = true, normalize = true)\n\nsolution_crank, rel_crank = crank_nicholson_method(A, u₀, init, steps; return_error = true, tt_solver = \"mals\")\n\nsolution_krylov, rel_krylov = expintegrator(A, last(steps), u₀)","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"And we can evaluate the solution on the grid at the final time step for visualization","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"x\", ylabel = \"u(x)\", title = \"Comparison of Time-Stepping Methods\")\nlines!(ax, xes, qtt_to_function(solution_implicit), label = \"Implicit Euler\", linestyle = :dot, linewidth = 3)\nlines!(ax, xes, qtt_to_function(solution_crank), label = \"Crank-Nicolson\", linestyle = :dash, linewidth = 3)\naxislegend(ax)\nfig","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"And similarly for the Krylov-based exponential integrator","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"fig = Figure()\nax = Axis(fig[1, 1], xlabel = \"x\", ylabel = \"u(x)\", title = \"Comparison of Time-Stepping Methods\")\nlines!(ax, xes, qtt_to_function(solution_krylov), label = \"Krylov\", linestyle = :solid, linewidth = 3)\naxislegend(ax)\nfig","category":"page"},{"location":"theory/","page":"Quantics tensor trains","title":"Quantics tensor trains","text":"For more solvers check out the solvers.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Partial-differential-equations","page":"Examples","title":"Partial differential equations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's consider the following 2D partial differential equation ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Delta u(xy) = f(xy)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where Delta is the Laplacian operator, u(xy) is the unknown function, and f(xy) is a given function. In this example we assume f(xy)=0 using Dirichlet-Dirichlet boundary conditions given by u(0y) = cos(pi y), u(1y) = sin(y).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We want to solve this equation using quantics tensor trains (QTTs).  We start by defining the dimensions and the resolution of the grid. Lets say we want 2^10 points in each dimension, which gives us a grid of 1024 times 1024 points on a 01times 01 grid. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using TensorTrainNumerics\nusing CairoMakie\n\nd = 10\na = 0.0\nb = 1.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We follow the same convention as in [15] where we define the finite difference operator using the following inputs","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"h = (b-a)/(2^d)\np = 1.0\ns = 0.0\nv = 0.0\nα = h^2*v-2*p\nβ = p + h*s/2\nγ = p-h*s/2\n\nΔ = toeplitz_to_qtto(α, β, γ, d) ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To get the 2D Laplacian operator, we need to take the Kronecker product of the 1D Laplacian operator with the identity. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A = Δ ⊗ id_tto(d) + id_tto(d) ⊗ Δ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To build the boundary vector we take the Kronecker product with the QTT basis vectors and define some random initial guess for the solution. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"b = qtt_cos(d) ⊗ qtt_basis_vector(d, 1) + qtt_sin(d) ⊗ qtt_basis_vector(d, 2^d) \ninitial_guess = rand_tt(b.ttv_dims, b.ttv_rks)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We solve the linear system using DMRG","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"x_dmrg = dmrg_linsolve(A, b, initial_guess; sweep_count=50,tol=1e-15)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And we reshape the solution to a 2D array for visualization","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nsolution = reshape(qtt_to_function(x_dmrg), 2^d, 2^d)\nxes = collect(range(0,1,length=2^d))\nyes = collect(range(0,1,length=2^d))\nfig = Figure()\ncmap = :roma\nax = Axis(fig[1, 1], title = \"Laplace Solution\", xlabel = \"x\", ylabel = \"y\")\nhm = heatmap!(ax, xes, yes, solution; colormap = cmap)\nColorbar(fig[1, 2], hm, label = \"u(x, y)\")\nfig","category":"page"},{"location":"examples/#Time-stepping","page":"Examples","title":"Time-stepping","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also solve time-dependent PDEs using the QTT framework. In this example we will use the explicit Euler method, the implicit Euler method and the Crank-Nicolson scheme.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using TensorTrainNumerics\nusing CairoMakie\n\nd = 8\nh = 1/d^2\nA = h^2*toeplitz_to_qtto(-2,1.0,1.0,d)\nxes = collect(range(0.0, 1.0, 2^d))\n\nu₀ = qtt_sin(d,λ=π)\ninit = rand_tt(u₀.ttv_dims, u₀.ttv_rks)\nsteps = collect(range(0.0,10.0,1000))\nsolution_explicit, error_explicit = euler_method(A, u₀, steps; return_error=true)\n\nsolution_implicit, rel_implicit = implicit_euler_method(A, u₀, init, steps; return_error=true)\n\nsolution_crank, rel_crank = crank_nicholson_method(A, u₀, init, steps; return_error=true, tt_solver=\"mals\")\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"x\", ylabel = \"u(x)\", title = \"Comparison of Time-Stepping Methods\")\nlines!(ax, xes, qtt_to_function(solution_explicit), label = \"Explicit Euler\", linestyle = :solid, linewidth=3)\nlines!(ax, xes, qtt_to_function(solution_implicit), label = \"Implicit Euler\", linestyle = :dot, linewidth=3)\nlines!(ax, xes, qtt_to_function(solution_crank), label = \"Crank-Nicolson\", linestyle = :dash, linewidth=3)\naxislegend(ax)\nfig","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And print the relative errors","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(\"Relative error for explicit Euler: \", error_explicit)\nprintln(\"Relative error for implicit Euler: \", rel_implicit)\nprintln(\"Relative error for Crank-Nicolson: \", rel_crank)","category":"page"},{"location":"examples/#Discrete-Fourier-Transform","page":"Examples","title":"Discrete Fourier Transform","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Based on [13] we also have access to the discrete Fourier transform (DFT) in QTT format. Below is an esample of how to use it. You can use the fourier_qtto function to create a QTT representation of the Fourier transform operator where the sign parameter determines if its the Fourier transform or the inverse Fourier transform. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using TensorTrainNumerics   \nusing Random \n\nd = 10\nN = 2^d\nK = 50\nsign = -1.0\nnormalize = true\n\nRandom.seed!(1234)\nr = 12\ncoeffs = randn(r) .+ 1im * randn(r)\n\nf(x) = sum(coeffs .* cispi.(2 .* (0:(r - 1)) .* x))\n\nF = fourier_qtto(d; K = K, sign = -1.0, normalize = true)\nx_qtt = function_to_qtt_uniform(f, d)\ny_qtt = F * x_qtt","category":"page"},{"location":"examples/#Variational-solver","page":"Examples","title":"Variational solver","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can also solve differential equations by optimizing a variational functional. Below is an example of how to use the variational_solver function to solve a simple differential equation based on - OptimKit.jl ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using TensorTrainNumerics\nusing OptimKit\nusing KrylovKit\n\nd = 6\nN = 2^d\nh = 1 / (N - 1)\nΔ = toeplitz_to_qtto(2.0, -1.0, -1.0, d)\nkappa = 0.1\nA = kappa * Δ\n\nf = qtt_sin(d, λ = π)\n\nfunction fg(u::TTvector)\n    û  = orthogonalize(u)           \n    Au = A*û                       \n    val = 0.5 * real(dot(û, Au)) - real(dot(f, û))\n    grad = Au - f\n    return val, grad\nend\n\nx0 = rand_tt(f.ttv_dims, f.ttv_rks)\n\nmethod = GradientDescent()\nx, fx, gx, numfg, normgradhistor = optimize(fg, x0, method)\n\nrelres = norm(A * x - f) / max(norm(f), eps())\n\nx_mals = mals_linsolve(A, f, x0)\nrel_residual = norm(A * x_mals - f) / max(norm(f), eps())\n\nx_krylov, info = linsolve(A, f, x0)\nrelres_krylov = norm(A * x_krylov - f) / max(norm(f), eps())","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"with a relative residual of","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(\"relative residual = \", relres)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Compared to the MALS solver","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(\"relative residual MALS = \", rel_residual)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And the Krylov solver","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(\"relative residual Krylov = \", relres_krylov)","category":"page"},{"location":"#TensorTrainNumerics.jl","page":"TensorTrainNumerics.jl","title":"TensorTrainNumerics.jl","text":"","category":"section"},{"location":"","page":"TensorTrainNumerics.jl","title":"TensorTrainNumerics.jl","text":"TensorTrainNumerics.jl is a Julia package designed to provide numerical methods for working with tensor trains (TT) and quantics tensor trains (QTT). ","category":"page"},{"location":"","page":"TensorTrainNumerics.jl","title":"TensorTrainNumerics.jl","text":"There are many packages for tensor decompositions and tensor network algorithms, but this package focuses on numerical methods and applications in scientific computing, such as solving high-dimensional partial differential equations (PDEs) and large-scale linear algebra problems. Thanks to VectorInterface.jl this package is compatible with many Krylov methods from KrylovKit.jl and optimization methods from OptimKit.jl. So far this package includes implementations of discrete Laplace operators in the quantics tensor train format as well as iterative solvers for linear systems and eigenvalue problems. ","category":"page"},{"location":"#Features","page":"TensorTrainNumerics.jl","title":"Features","text":"","category":"section"},{"location":"","page":"TensorTrainNumerics.jl","title":"TensorTrainNumerics.jl","text":"Tensor Train Decomposition: Algorithms for decomposing high-dimensional tensors into tensor train format [1, 2].\nTensor Operations: Support for basic tensor operations such as addition, multiplication, the hadamard product in tensor train format [3].\nDiscrete Operators: Implementation of discrete Laplacians, gradient operators, and shift matrices in tensor train format for solving partial differential equations [4–6].\nQuantized Tensor Trains: Tools for constructing and manipulating quantized tensor trains, which provide further compression and efficiency for large-scale problems.\nIterative Solvers: Integration with iterative solvers for solving linear systems and eigenvalue problems in tensor train format [7–10].\nThe Fourier transform in QTT format and interpolation in QTT format [11–14].\nVisualization: Basic visualization tools. ","category":"page"},{"location":"#Getting-started","page":"TensorTrainNumerics.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"TensorTrainNumerics.jl","title":"TensorTrainNumerics.jl","text":"You can install the package using Julia's package manager:","category":"page"},{"location":"","page":"TensorTrainNumerics.jl","title":"TensorTrainNumerics.jl","text":"using Pkg\nPkg.add(\"TensorTrainNumerics\")","category":"page"},{"location":"","page":"TensorTrainNumerics.jl","title":"TensorTrainNumerics.jl","text":"For some examples check out the examples page or the examples folder on Github.","category":"page"},{"location":"API/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"API/#Tensor-Train-Vector-(TTvector)","page":"Docstrings","title":"Tensor Train Vector (TTvector)","text":"","category":"section"},{"location":"API/#TensorTrainNumerics.TTvector-API","page":"Docstrings","title":"TensorTrainNumerics.TTvector","text":"A structure representing a Tensor Train (TT) vector.\n\nFields\n\nN::Int64: The number of elements in the TT vector.\nttv_vec::Vector{Array{T,3}}: A vector of 3-dimensional arrays representing the TT d.\nttv_dims::NTuple{M,Int64}: A tuple containing the dimensions of the TT vector.\nttv_rks::Vector{Int64}: A vector containing the TT ranks.\nttv_ot::Vector{Int64}: A vector containing the orthogonalization information.\n\nType Parameters\n\nT<:Number: The type of the elements in the TT vector.\n\n\n\n\n\n","category":"type"},{"location":"API/#Tensor-Train-Operator-(TToperator)","page":"Docstrings","title":"Tensor Train Operator (TToperator)","text":"","category":"section"},{"location":"API/#TensorTrainNumerics.TToperator-API","page":"Docstrings","title":"TensorTrainNumerics.TToperator","text":"A structure representing a Tensor Train (TT) operator.\n\nFields\n\nN::Int64: The number of dimensions of the TT operator.\ntto_vec::Array{Array{T,4},1}: A vector of 4-dimensional arrays representing the TT d.\ntto_dims::NTuple{M,Int64}: A tuple containing the dimensions of the TT operator.\ntto_rks::Array{Int64,1}: An array containing the TT ranks.\ntto_ot::Array{Int64,1}: An array containing the output dimensions of the TT operator.\n\nType Parameters\n\nT<:Number: The type of the elements in the TT vector.\n\n\n\n\n\n","category":"type"},{"location":"API/#QTT-Tools","page":"Docstrings","title":"QTT Tools","text":"","category":"section"},{"location":"API/#TensorTrainNumerics.qtt_exp-API","page":"Docstrings","title":"TensorTrainNumerics.qtt_exp","text":"Constructs a Quantized Tensor Train (QTT) representation of the exponential function over a uniform grid in the interval [a, b] with 2^d points.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.qtt_sin-API","page":"Docstrings","title":"TensorTrainNumerics.qtt_sin","text":"Constructs a Quantized Tensor Train (QTT) representation of sin(λπx) over a uniform grid in the interval [a, b] with 2^d points.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.qtt_cos-API","page":"Docstrings","title":"TensorTrainNumerics.qtt_cos","text":"Constructs a Quantized Tensor Train (QTT) representation of cos(λπx) over a uniform grid in the interval [a, b] with 2^d points.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.qtt_polynom-API","page":"Docstrings","title":"TensorTrainNumerics.qtt_polynom","text":"Constructs a Quantized Tensor Train (QTT) representation a polynomial with given coefficients over a uniform grid in the interval [a, b] with 2^d points.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.qtt_chebyshev-API","page":"Docstrings","title":"TensorTrainNumerics.qtt_chebyshev","text":"Constructs a Quantized Tensor Train (QTT) representation of the Chebyshev polynomial of degree n over 2^d Chebyshev-Lobatto nodes.\n\nDetails\n\nThe function uses the Gauss-Chebyshev-Lobatto nodes, shifted to the interval [0, 1].\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.qtt_to_function-API","page":"Docstrings","title":"TensorTrainNumerics.qtt_to_function","text":"Converts a quantized tensor train (QTT) vector qtt into a function representation.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.function_to_qtt-API","page":"Docstrings","title":"TensorTrainNumerics.function_to_qtt","text":"Converts a univariate function f into its Quantized Tensor Train (QTT) representation.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.qtto_to_matrix-API","page":"Docstrings","title":"TensorTrainNumerics.qtto_to_matrix","text":"Converts a quantum tensor train operator (TToperator) into its full matrix representation.\n\n\n\n\n\n","category":"function"},{"location":"API/#Operators","page":"Docstrings","title":"Operators","text":"","category":"section"},{"location":"API/#TensorTrainNumerics.toeplitz_to_qtto-API","page":"Docstrings","title":"TensorTrainNumerics.toeplitz_to_qtto","text":"Constructs a tensor train operator (TTO) representation of a Toeplitz matrix parameterized by α, β, and γ over d dimensions.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.shift-API","page":"Docstrings","title":"TensorTrainNumerics.shift","text":"Constructs a tensor train operator (TTO) representation of the shift matrix\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.∇-API","page":"Docstrings","title":"TensorTrainNumerics.∇","text":"Constructs a tensor train operator (TTO) representation of the gradient matrix\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.Δ-API","page":"Docstrings","title":"TensorTrainNumerics.Δ","text":"Constructs a tensor train operator (TTO) representation of the Laplacian with Dirichlet-Dirichlet boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.Δ_DN-API","page":"Docstrings","title":"TensorTrainNumerics.Δ_DN","text":"Constructs a tensor train operator (TTO) representation of the Laplacian with Dirichlet-Neumann boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.Δ_ND-API","page":"Docstrings","title":"TensorTrainNumerics.Δ_ND","text":"Constructs a tensor train operator (TTO) representation of the Laplacian with Neumann-Dirichlet boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.Δ_NN-API","page":"Docstrings","title":"TensorTrainNumerics.Δ_NN","text":"Constructs a tensor train operator (TTO) representation of the Laplacian with Neumann-Neumann boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.Δ_P-API","page":"Docstrings","title":"TensorTrainNumerics.Δ_P","text":"Constructs a tensor train operator (TTO) representation of the Laplacian with periodic boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.Δ⁻¹_DN-API","page":"Docstrings","title":"TensorTrainNumerics.Δ⁻¹_DN","text":"Constructs a tensor train operator (TTO) representation of the inverse Laplacian with Dirichlet-Neumann boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.qtto_prolongation-API","page":"Docstrings","title":"TensorTrainNumerics.qtto_prolongation","text":"Constructs a tensor train operator (TTO) representation of the prolongation operator for multigrid methods\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.id_tto-API","page":"Docstrings","title":"TensorTrainNumerics.id_tto","text":"id_tto(d; n_dim=2)\n\nCreate an identity tensor train operator (TTO) of dimension d with optional keyword argument n_dim specifying the number of dimensions (default is 2).\n\nArguments\n\nd::Int: The dimension of the identity tensor train operator.\nn_dim::Int: The number of dimensions of the identity tensor train operator (default is 2).\n\nReturns\n\nAn identity tensor train operator of the specified dimension and number of dimensions.\n\n\n\n\n\n","category":"function"},{"location":"API/#Operations","page":"Docstrings","title":"Operations","text":"","category":"section"},{"location":"API/#TensorTrainNumerics.dot-API","page":"Docstrings","title":"TensorTrainNumerics.dot","text":"Computes the dot product of two TTvectors and returns a scalar.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.concatenate-API","page":"Docstrings","title":"TensorTrainNumerics.concatenate","text":"Concatenates two TTvectors along their dimensions and returns a new TTvector.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.ttv_to_diag_tto-API","page":"Docstrings","title":"TensorTrainNumerics.ttv_to_diag_tto","text":"Creates a diagonal TToperator from a TTvector.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.permute-API","page":"Docstrings","title":"TensorTrainNumerics.permute","text":"Permutes the dimensions of a TTvector according to the specified order and returns a new TTvector.\n\n\n\n\n\n","category":"function"},{"location":"API/#TensorTrainNumerics.hadamard-API","page":"Docstrings","title":"TensorTrainNumerics.hadamard","text":"Computes the Hadamard product (element-wise multiplication) of two TTvectors and returns a new TTvector.\n\n\n\n\n\n","category":"function"},{"location":"API/#Base.kron-API","page":"Docstrings","title":"Base.kron","text":"kron(A, B)\n\nComputes the Kronecker product of two vectors, matrices or numbers.\n\nFor real vectors v and w, the Kronecker product is related to the outer product by kron(v,w) == vec(w * transpose(v)) or w * transpose(v) == reshape(kron(v,w), (length(w), length(v))). Note how the ordering of v and w differs on the left and right of these expressions (due to column-major storage). For complex vectors, the outer product w * v' also differs by conjugation of v.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> B = [im 1; 1 -im]\n2×2 Matrix{Complex{Int64}}:\n 0+1im  1+0im\n 1+0im  0-1im\n\njulia> kron(A, B)\n4×4 Matrix{Complex{Int64}}:\n 0+1im  1+0im  0+2im  2+0im\n 1+0im  0-1im  2+0im  0-2im\n 0+3im  3+0im  0+4im  4+0im\n 3+0im  0-3im  4+0im  0-4im\n\njulia> v = [1, 2]; w = [3, 4, 5];\n\njulia> w*transpose(v)\n3×2 Matrix{Int64}:\n 3   6\n 4   8\n 5  10\n\njulia> reshape(kron(v,w), (length(w), length(v)))\n3×2 Matrix{Int64}:\n 3   6\n 4   8\n 5  10\n\n\n\n\n\nkron(A::LinearMap, B::LinearMap)::KroneckerMap\nkron(A, B, Cs...)::KroneckerMap\n\nConstruct a (lazy) representation of the Kronecker product A⊗B. One of the two factors can be an AbstractMatrix, which is then promoted to a LinearMap automatically.\n\nTo avoid fallback to the generic Base.kron in the multi-map case, there must be a LinearMap object among the first 8 arguments in usage like kron(A, B, Cs...).\n\nFor convenience, one can also use A ⊗ B or ⊗(A, B, Cs...) (typed as \\otimes+TAB) to construct the KroneckerMap, even when all arguments are of AbstractMatrix type.\n\nIf A, B, C and D are linear maps of such size that one can form the matrix products A*C and B*D, then the mixed-product property (A⊗B)*(C⊗D) = (A*C)⊗(B*D) holds. Upon vector multiplication, this rule is checked for applicability.\n\nExamples\n\njulia> J = LinearMap(I, 2) # 2×2 identity map\n2×2 LinearMaps.UniformScalingMap{Bool} with scaling factor: true\n\njulia> E = spdiagm(-1 => trues(1)); D = E + E' - 2I;\n\njulia> Δ = kron(D, J) + kron(J, D); # discrete 2D-Laplace operator\n\njulia> Matrix(Δ)\n4×4 Matrix{Int64}:\n -4   1   1   0\n  1  -4   0   1\n  1   0  -4   1\n  0   1   1  -4\n\n\n\n\n\nComputes the Kronecker product of two TToperators and returns a new TToperator.\n\n\n\n\n\nComputes the Kronecker product of two TTvectors and returns a new TTvector.\n\n\n\n\n\n","category":"function"}]
}
